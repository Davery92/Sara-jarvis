#!/usr/bin/env python3
"""
Daily Vulnerability Report Generation Script (Direct Database Access)
Runs at 5am daily to generate vulnerability intelligence reports
Bypasses API authentication by working directly with database
"""

import asyncio
import aiohttp
import logging
import os
import sys
import json
import uuid
from datetime import datetime, timezone
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker

# Add backend to Python path
sys.path.insert(0, '/home/david/jarvis/backend')

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/home/david/jarvis/logs/vulnerability_reports.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Database configuration
DATABASE_URL = "postgresql+psycopg://sara:sara123@10.185.1.180:5432/sara_hub"
NTFY_TOPIC = "sara_vulnerabilities"

class VulnReportService:
    def __init__(self):
        self.engine = create_engine(DATABASE_URL)
        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
    
    async def fetch_vulnerability_data(self):
        """Fetch vulnerability data from multiple sources"""
        logger.info("üì° Fetching vulnerability intelligence from sources...")
        
        vulnerability_data = {
            'msrc_advisories': [],
            'cisa_kev': [],
            'nvd_recent': [],
            'project_zero': [],
            'exploit_db': []
        }
        
        # Create aiohttp session with proper timeout
        timeout = aiohttp.ClientTimeout(total=60)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            # CISA Known Exploited Vulnerabilities
            try:
                logger.info("üéØ Fetching CISA KEV catalog...")
                async with session.get('https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json') as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        # Get recent KEV entries (last 30 days)
                        vulnerability_data['cisa_kev'] = data.get('vulnerabilities', [])[:50]
                        logger.info(f"‚úÖ Retrieved {len(vulnerability_data['cisa_kev'])} CISA KEV entries")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Failed to fetch CISA KEV: {e}")
            
            # Microsoft Security Response Center
            try:
                logger.info("ü™ü Fetching MSRC advisories...")
                async with session.get('https://api.msrc.microsoft.com/cvrf/v2.0/updates') as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        vulnerability_data['msrc_advisories'] = data.get('value', [])[:20]
                        logger.info(f"‚úÖ Retrieved {len(vulnerability_data['msrc_advisories'])} MSRC advisories")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Failed to fetch MSRC data: {e}")
        
        return vulnerability_data
    
    def generate_report_content(self, vuln_data):
        """Generate markdown report content"""
        report_date = datetime.now(timezone.utc).strftime("%Y-%m-%d")
        
        content = f"""# Daily Vulnerability Intelligence Report
**Generated**: {datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")}

## üéØ CISA Known Exploited Vulnerabilities (High Priority)

"""
        
        # CISA KEV section
        kev_count = len(vuln_data.get('cisa_kev', []))
        if kev_count > 0:
            content += f"**{kev_count} vulnerabilities currently listed in CISA KEV catalog**\n\n"
            content += "Recent high-priority vulnerabilities with active exploitation:\n\n"
            
            for vuln in vuln_data['cisa_kev'][:10]:
                cve = vuln.get('cveID', 'N/A')
                vendor = vuln.get('vendorProject', 'Unknown')
                product = vuln.get('product', 'Unknown')
                vuln_name = vuln.get('vulnerabilityName', 'Unknown')
                date_added = vuln.get('dateAdded', 'Unknown')
                due_date = vuln.get('dueDate', 'Unknown')
                
                content += f"### {cve}\n"
                content += f"- **Vendor/Product**: {vendor} {product}\n"
                content += f"- **Vulnerability**: {vuln_name}\n"
                content += f"- **Added to KEV**: {date_added}\n"
                content += f"- **Due Date**: {due_date}\n"
                content += f"- **Status**: üö® **ACTIVE EXPLOITATION**\n\n"
        else:
            content += "No CISA KEV data available.\n\n"
        
        # MSRC section
        content += "## ü™ü Microsoft Security Updates\n\n"
        msrc_count = len(vuln_data.get('msrc_advisories', []))
        if msrc_count > 0:
            content += f"**{msrc_count} recent Microsoft security advisories**\n\n"
            for advisory in vuln_data['msrc_advisories'][:5]:
                title = advisory.get('Title', 'Unknown')
                release_date = advisory.get('ReleaseDate', 'Unknown')
                content += f"- **{title}** (Released: {release_date})\n"
        else:
            content += "No MSRC data available.\n\n"
        
        # Summary and recommendations
        content += """## üìã Summary & Recommendations

### üö® Immediate Actions Required
- Review CISA KEV entries above - these have **active exploitation**
- Prioritize patching for any systems running affected products
- Verify security controls are in place for unpatched systems

### üìä Intelligence Summary
"""
        content += f"- **CISA KEV Entries**: {kev_count} actively exploited vulnerabilities\n"
        content += f"- **Microsoft Updates**: {msrc_count} recent security advisories\n"
        content += f"- **Report Generation**: {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')}\n\n"
        
        content += """### üîÑ Next Steps
1. **Patch Management**: Prioritize CISA KEV vulnerabilities
2. **Asset Inventory**: Identify systems running affected products  
3. **Monitoring**: Watch for IOCs related to active exploits
4. **Documentation**: Update security assessment with new findings

---
*Generated by Sara's Vulnerability Intelligence System*
"""
        
        return content
    
    def save_report_to_database(self, report_content, report_date, vuln_data):
        """Save report directly to database"""
        try:
            with self.SessionLocal() as db:
                # Insert report - need to add required fields based on actual schema
                insert_query = text("""
                    INSERT INTO vulnerability_report (
                        id, user_id, report_date, title, summary, content, 
                        vulnerabilities_count, critical_count, kev_count
                    )
                    VALUES (
                        :id, :user_id, :report_date, :title, :summary, :content,
                        :vulnerabilities_count, :critical_count, :kev_count
                    )
                    ON CONFLICT (report_date) DO UPDATE SET
                        title = EXCLUDED.title,
                        summary = EXCLUDED.summary,
                        content = EXCLUDED.content,
                        vulnerabilities_count = EXCLUDED.vulnerabilities_count,
                        critical_count = EXCLUDED.critical_count,
                        kev_count = EXCLUDED.kev_count
                """)
                
                # Get user_id - we'll use the first user for now (David)
                user_query = text("SELECT id FROM app_user WHERE email = 'david@avery.cloud' LIMIT 1")
                user_result = db.execute(user_query).fetchone()
                user_id = user_result[0] if user_result else "default_user"
                
                db.execute(insert_query, {
                    "id": str(uuid.uuid4()),
                    "user_id": user_id,
                    "report_date": datetime.combine(report_date, datetime.min.time()),
                    "title": f"Daily Vulnerability Intelligence Report - {report_date}",
                    "summary": f"Daily intelligence report with {len(vuln_data.get('cisa_kev', []))} KEV entries and {len(vuln_data.get('msrc_advisories', []))} Microsoft advisories",
                    "content": report_content,
                    "vulnerabilities_count": len(vuln_data.get('cisa_kev', [])) + len(vuln_data.get('msrc_advisories', [])),
                    "critical_count": len([v for v in vuln_data.get('cisa_kev', []) if v.get('cveID', '').startswith('CVE-2024')]),
                    "kev_count": len(vuln_data.get('cisa_kev', []))
                })
                db.commit()
                logger.info(f"‚úÖ Report saved to database for {report_date}")
                return True
        except Exception as e:
            logger.error(f"‚ùå Failed to save report to database: {e}")
            return False
    
    async def send_ntfy_notification(self, title, message, priority="default"):
        """Send notification via NTFY"""
        try:
            async with aiohttp.ClientSession() as session:
                await session.post(
                    f"https://ntfy.sh/{NTFY_TOPIC}",
                    headers={
                        "Title": title,
                        "Priority": priority
                    },
                    data=message.encode('utf-8')
                )
                logger.info(f"üì± Sent NTFY notification: {title}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Failed to send NTFY notification: {e}")

async def main():
    """Main execution function"""
    start_time = datetime.now()
    logger.info(f"üåÖ Starting daily vulnerability report generation at {start_time}")
    
    try:
        service = VulnReportService()
        
        # Fetch vulnerability data
        vuln_data = await service.fetch_vulnerability_data()
        
        # Generate report content
        report_content = service.generate_report_content(vuln_data)
        report_date = datetime.now(timezone.utc).date()
        
        # Save to database
        success = service.save_report_to_database(report_content, report_date, vuln_data)
        
        if success:
            # Count high-priority items for notification
            kev_count = len(vuln_data.get('cisa_kev', []))
            msrc_count = len(vuln_data.get('msrc_advisories', []))
            
            # Send success notification
            await service.send_ntfy_notification(
                "üõ°Ô∏è Daily Vulnerability Report Ready",
                f"Generated report for {report_date}\n‚Ä¢ {kev_count} CISA KEV entries\n‚Ä¢ {msrc_count} Microsoft advisories\n\nView in Sara Hub ‚Üí Vulnerability Watch",
                priority="high" if kev_count > 0 else "default"
            )
            
            duration = (datetime.now() - start_time).total_seconds()
            logger.info(f"‚úÖ Daily vulnerability report generation completed successfully in {duration:.2f} seconds")
        else:
            await service.send_ntfy_notification(
                "‚ùå Vulnerability Report Failed", 
                "Database save failed. Check logs for details.",
                priority="high"
            )
            
    except Exception as e:
        duration = (datetime.now() - start_time).total_seconds()
        logger.error(f"‚ùå Daily vulnerability report generation failed after {duration:.2f} seconds")
        logger.error(f"Error: {e}", exc_info=True)
        
        # Send failure notification
        service = VulnReportService()
        await service.send_ntfy_notification(
            "‚ùå Vulnerability Report Failed", 
            f"Report generation failed: {str(e)[:100]}",
            priority="high"
        )
        return False

if __name__ == "__main__":
    asyncio.run(main())